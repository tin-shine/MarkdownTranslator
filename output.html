<h1>构建MenuOS系统</h1>
<ol start="1"><li>将指定文件拷贝到本地：</li></ol>
<code><pre>git clone https://github.com/mengning/linuxnet.git
</pre></code>
<p>此过程可能需要输入github账号和密码。</p><img src="https://img2018.cnblogs.com/blog/1159589/201912/1159589-20191205203448231-329234055.png" alt="">
<ol start="2"><li>进入目录<code>linuxnet</code>，使用<code>make</code>命令编译根文件系统：</li></ol>
<code><pre>cd linuxnet
make rootfs
</pre></code>
<ol start="3"><li>在<code>Makefile</code>文件中有一条指令用于开启menu系统（不需要自己输入）：</li></ol>
<code><pre>qmenu -kernel ../../linux-3.18.6/arch/x86/bzImage -initrd ../rootfs.img
</pre></code>
<img src="https://img2018.cnblogs.com/blog/1159589/201912/1159589-20191205203508070-318162709.png" alt="">
<h1>测试QEMU</h1>
<ol start="1"><li>在QEMU中完成TCP客户端和服务器发送和接收hello/hi以验证MenuOS正常工作：</li></ol>
<code><pre>MenuOS>> replyhi
# Please input hello...
MenuOS>> hello
</pre></code>
<img src="https://img2018.cnblogs.com/blog/1159589/201912/1159589-20191205203722622-532727367.png" alt="">
<ul><li>结果显示TCP客户端和服务器正常工作，打印出了预期的信息</li></ul>
<ol start="2"><li>修改Makefile内容，<code>rootfs</code>标签下启动QEMU的命令尾部添加<code>-s</code></li></ol>
<img src="https://img2018.cnblogs.com/blog/1159589/201912/1159589-20191205203748364-1937590936.png" alt="">
<ol start="3"><li>重新<code>make rootfs</code>，启动QEMU</li></ol>
<img src="https://img2018.cnblogs.com/blog/1159589/201912/1159589-20191205203802697-1331608278.png" alt="">
<ol start="4"><li>启动调试，连接到server</li></ol>
<code><pre>gdb
(gdb) file ../../linux-3.18.6/vmlinux
(gdb) target remote:1234    # 连接到gdbserver
</pre></code>
<ol start="5"><li>设置断点，验证gdb对<code>start_kernel</code>和<code>sys_socketcall</code>这两个内核函数的跟踪是否可行</li></ol>
<code><pre>(gdb) break start_kernel
(gdb) break sys_socketcall
</pre></code>
<img src="https://img2018.cnblogs.com/blog/1159589/201912/1159589-20191205203810157-489961735.png" alt="">
<ul><li>结果显示gdb可以追踪到<code>start_kernel</code>函数，断点在<code>init/mian.c</code>的501行；也可以追踪到<code>sys_socketcall</code>函数，断点在<code>net/socket.c</code>文件的2492行</li></ul>

